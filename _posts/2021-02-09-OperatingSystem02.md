---
layout: post
title: (운영체제) Two-Level Page Table
tags:
  - 운영체제
---

<br>

>[운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 강의를 보면서 헷갈렸던 부분을 정리한 내용

<br>

- 32bit 주소 체계를 사용하는 컴퓨터에서 표현할 수 있는 주소의 범위는  `2^32` 개 이다. 그리고 컴퓨터는 1byte 단위로 메모리 주소를 부여하기 때문에 결론적으로 `4GB(2^32 byte)` 만큼의 주소 공간을 가지게 된다.
- 이때, page size가 `4KB(2^12 byte)` 라고 하면, `address space(=4GB)` 는 `4KB`로 나눈 값인 `2^20(약 100만)` 개의 페이지로  나뉘어진다. 페이지 테이블은 페이지의 갯수인 `2^20` 개의 엔트리를 가지게 된다.
- 32bit 주소 체계를 사용하기 때문에, page table의 하나의 entry는 `4byte`가 할당된다.
- 따라서, 프로세스 마다 `2^20 entry ` x `4 byte`= `2^22 byte` = `4MB` 크기의 page table을 가지게 된다
- 이 page table은 프로그램이 메모리에 올라갈 때 physical memory에 할당된다. 그러나 대부분의 프로그램은 주소 공간 중 일부만 사용하기 때문에 physical memory의 공간 낭비 문제가 발생한다. 

- 이 문제를 해결하기 위해서  `Two-Level Page Table` 을 사용한다.

<br>

### Two-Level Page Table

- 큰 페이지 테이블을 여러개의 작은 조각(페이지)으로 나눈다. (페이징)
  - 이 조각(페이지)들의 모음을 가진 테이블이 안쪽 테이블
  - Invalid한 페이지를 할당하지 않으므로 메모리를 절약할 수 있다.
  - 이 조각(페이지)들을 가리키는 바깥쪽 테이블 

- 논리주소 <p1,p2,d>
  - p1: 바깥 테이블의 인덱스
  - p2 : 바깥 테이블의 <b>페이지</b> 에서의 변위
-  4KB의 페이지 크기를 가진 32bit 환경을 예로 들면, 논리주소는 20bit 짜리 페이지 번호와 12bit의 페이지 변위로 이루어 진다. 
  - 왜 12bit page offset 일까?
    - 물리메모리의 프레임 크기도 4KB(=2^12)이기 때문에 한 프레임 내부 위치를 구분하기 위해서는 12bit가 필요하다
  - offset 12bit 사용하고 나머지 20bit(32bit - 12bit)는 페이지 번호로 사용
-  20bit 페이지 번호는 다시10bit짜리 페이지 번호와 10bit짜리 페이지 변위로 나누어 진다.
  - 안쪽 페이지 테이블의 한 조각의 크기는 페이지 크기(4KB)와 똑같다
  - 한 조각 내부에 있는 엔트리의 크기는 4B이다
  - 따라서 한 페이지 내 주소공간 구분을 위해 10bit가 필요하다 (4KB/4B = 2^10)
  - 32bit - 22bit = 10bit 으로 바깥 테이블을 위해 10bit가 필요하다
